<template>
  <div class="code-tab">
    <div class="title fm-hi">
      TopShotMarketV3.cdc
    </div>
    <ace-editor
      ref="aceEditor"
      :content="code"
      :read-only="true"
      :config="{
        fontSize: '12px',
        maxLines: Infinity
      }"
    />
  </div>
</template>

<script>
import AceEditor from '@/components/AceEditor';
export default {
  name: 'ScriptTab',
  components: { AceEditor },
  data() {
    return { code: '' };
  },
  computed: {},
  mounted() {
    setTimeout(() => {
      this.code = "import FungibleToken from 0xf233dcee88fe0abe\n\npub contract TeleportedTetherToken: FungibleToken {\n  // Frozen flag controlled by Admin\n  pub var isFrozen: Bool\n\n  // Total supply of TeleportedTetherTokens in existence\n  pub var totalSupply: UFix64\n\n  // Record teleported Ethereum hashes\n  pub var teleported: {String: Bool}\n\n  // Defines token vault storage path\n  pub let TokenStoragePath: StoragePath\n\n  // Defines token vault public balance path\n  pub let TokenPublicBalancePath: PublicPath\n\n  // Defines token vault public receiver path\n  pub let TokenPublicReceiverPath: PublicPath\n\n  // Event that is emitted when the contract is created\n  pub event TokensInitialized(initialSupply: UFix64)\n\n  // Event that is emitted when tokens are withdrawn from a Vault\n  pub event TokensWithdrawn(amount: UFix64, from: Address?)\n\n  // Event that is emitted when tokens are deposited to a Vault\n  pub event TokensDeposited(amount: UFix64, to: Address?)\n\n  // Event that is emitted when new tokens are teleported in from Ethereum (from: Ethereum Address, 20 bytes)\n  pub event TokensTeleportedIn(amount: UFix64, from: [UInt8], hash: String)\n\n  // Event that is emitted when tokens are destroyed and teleported to Ethereum (to: Ethereum Address, 20 bytes)\n  pub event TokensTeleportedOut(amount: UFix64, to: [UInt8])\n\n  // Event that is emitted when teleport fee is collected (type 0: out, 1: in)\n  pub event FeeCollected(amount: UFix64, type: UInt8)\n\n  // Event that is emitted when a new burner resource is created\n  pub event TeleportAdminCreated(allowedAmount: UFix64)\n\n  // Vault\n  //\n  // Each user stores an instance of only the Vault in their storage\n  // The functions in the Vault and governed by the pre and post conditions\n  // in FungibleToken when they are called.\n  // The checks happen at runtime whenever a function is called.\n  //\n  // Resources can only be created in the context of the contract that they\n  // are defined in, so there is no way for a malicious user to create Vaults\n  // out of thin air. A special Minter resource needs to be defined to mint\n  // new tokens.\n  //\n  pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {\n    \n    // holds the balance of a users tokens\n    pub var balance: UFix64\n\n    // initialize the balance at resource creation time\n    init(balance: UFix64) {\n      self.balance = balance\n    }\n\n    // withdraw\n    //\n    // Function that takes an integer amount as an argument\n    // and withdraws that amount from the Vault.\n    // It creates a new temporary Vault that is used to hold\n    // the money that is being transferred. It returns the newly\n    // created Vault to the context that called so it can be deposited\n    // elsewhere.\n    //\n    pub fun withdraw(amount: UFix64): @FungibleToken.Vault {\n      self.balance = self.balance - amount\n      emit TokensWithdrawn(amount: amount, from: self.owner?.address)\n      return \u003c- create Vault(balance: amount)\n    }\n\n    // deposit\n    //\n    // Function that takes a Vault object as an argument and adds\n    // its balance to the balance of the owners Vault.\n    // It is allowed to destroy the sent Vault because the Vault\n    // was a temporary holder of the tokens. The Vault's balance has\n    // been consumed and therefore can be destroyed.\n    pub fun deposit(from: @FungibleToken.Vault) {\n      let vault \u003c- from as! @TeleportedTetherToken.Vault\n      self.balance = self.balance + vault.balance\n      emit TokensDeposited(amount: vault.balance, to: self.owner?.address)\n      vault.balance = 0.0\n      destroy vault\n    }\n\n    destroy() {\n      TeleportedTetherToken.totalSupply = TeleportedTetherToken.totalSupply - self.balance\n    }\n  }\n\n  // createEmptyVault\n  //\n  // Function that creates a new Vault with a balance of zero\n  // and returns it to the calling context. A user must call this function\n  // and store the returned Vault in their storage in order to allow their\n  // account to be able to receive deposits of this token type.\n  //\n  pub fun createEmptyVault(): @FungibleToken.Vault {\n    return \u003c- create Vault(balance: 0.0)\n  }\n\n  pub resource Allowance {\n    pub var balance: UFix64\n\n    // initialize the balance at resource creation time\n    init(balance: UFix64) {\n      self.balance = balance\n    }\n  }\n\n  pub resource Administrator {\n\n    // createNewTeleportAdmin\n    //\n    // Function that creates and returns a new teleport admin resource\n    //\n    pub fun createNewTeleportAdmin(allowedAmount: UFix64): @TeleportAdmin {\n      emit TeleportAdminCreated(allowedAmount: allowedAmount)\n      return \u003c- create TeleportAdmin(allowedAmount: allowedAmount)\n    }\n\n    pub fun freeze() {\n      TeleportedTetherToken.isFrozen = true\n    }\n\n    pub fun unfreeze() {\n      TeleportedTetherToken.isFrozen = false\n    }\n\n    pub fun createAllowance(allowedAmount: UFix64): @Allowance {\n      return \u003c- create Allowance(balance: allowedAmount)\n    }\n  }\n\n  pub resource interface TeleportUser {\n    // fee collected when token is teleported from Ethereum to Flow\n    pub var inwardFee: UFix64\n\n    // fee collected when token is teleported from Flow to Ethereum\n    pub var outwardFee: UFix64\n    \n    // the amount of tokens that the minter is allowed to mint\n    pub var allowedAmount: UFix64\n\n    // corresponding controller account on Ethereum\n    pub var ethereumAdminAccount: [UInt8]\n\n    pub fun teleportOut(from: @FungibleToken.Vault, to: [UInt8])\n\n    pub fun depositAllowance(from: @Allowance)\n  }\n\n  pub resource interface TeleportControl {\n    pub fun teleportIn(amount: UFix64, from: [UInt8], hash: String): @TeleportedTetherToken.Vault\n\n    pub fun withdrawFee(amount: UFix64): @FungibleToken.Vault\n    \n    pub fun updateInwardFee(fee: UFix64)\n\n    pub fun updateOutwardFee(fee: UFix64)\n\n    pub fun updateEthereumAdminAccount(account: [UInt8])\n  }\n\n  // TeleportAdmin resource\n  //\n  //  Resource object that has the capability to mint teleported tokens\n  //  upon receiving teleport request from Ethereum side\n  //\n  pub resource TeleportAdmin: TeleportUser, TeleportControl {\n    \n    // the amount of tokens that the minter is allowed to mint\n    pub var allowedAmount: UFix64\n\n    // receiver reference to collect teleport fee\n    pub let feeCollector: @TeleportedTetherToken.Vault\n\n    // fee collected when token is teleported from Ethereum to Flow\n    pub var inwardFee: UFix64\n\n    // fee collected when token is teleported from Flow to Ethereum\n    pub var outwardFee: UFix64\n\n    // corresponding controller account on Ethereum\n    pub var ethereumAdminAccount: [UInt8]\n\n    // teleportIn\n    //\n    // Function that mints new tokens, adds them to the total supply,\n    // and returns them to the calling context.\n    //\n    pub fun teleportIn(amount: UFix64, from: [UInt8], hash: String): @TeleportedTetherToken.Vault {\n      pre {\n        !TeleportedTetherToken.isFrozen: \"Teleport service is frozen\"\n        amount \u003c= self.allowedAmount: \"Amount minted must be less than the allowed amount\"\n        amount \u003e self.inwardFee: \"Amount minted must be greater than inward teleport fee\"\n        from.length == 20: \"Ethereum address should be 20 bytes\"\n        hash.length == 64: \"Ethereum tx hash should be 32 bytes\"\n        !(TeleportedTetherToken.teleported[hash] ?? false): \"Same hash already teleported\"\n      }\n      TeleportedTetherToken.totalSupply = TeleportedTetherToken.totalSupply + amount\n      self.allowedAmount = self.allowedAmount - amount\n\n      TeleportedTetherToken.teleported[hash] = true\n      emit TokensTeleportedIn(amount: amount, from: from, hash: hash)\n\n      let vault \u003c- create Vault(balance: amount)\n      let fee \u003c- vault.withdraw(amount: self.inwardFee)\n\n      self.feeCollector.deposit(from: \u003c-fee)\n      emit FeeCollected(amount: self.inwardFee, type: 1)\n\n      return \u003c- vault\n    }\n\n    // teleportOut\n    //\n    // Function that destroys a Vault instance, effectively burning the tokens.\n    //\n    // Note: the burned tokens are automatically subtracted from the \n    // total supply in the Vault destructor.\n    //\n    pub fun teleportOut(from: @FungibleToken.Vault, to: [UInt8]) {\n      pre {\n        !TeleportedTetherToken.isFrozen: \"Teleport service is frozen\"\n        to.length == 20: \"Ethereum address should be 20 bytes\"\n      }\n\n      let vault \u003c- from as! @TeleportedTetherToken.Vault\n      let fee \u003c- vault.withdraw(amount: self.outwardFee)\n\n      self.feeCollector.deposit(from: \u003c-fee)\n      emit FeeCollected(amount: self.outwardFee, type: 0)\n\n      let amount = vault.balance\n      destroy vault\n      emit TokensTeleportedOut(amount: amount, to: to)\n    }\n\n    pub fun withdrawFee(amount: UFix64): @FungibleToken.Vault {\n      return \u003c- self.feeCollector.withdraw(amount: amount)\n    }\n\n    pub fun updateInwardFee(fee: UFix64) {\n      self.inwardFee = fee\n    }\n\n    pub fun updateOutwardFee(fee: UFix64) {\n      self.outwardFee = fee\n    }\n\n    pub fun updateEthereumAdminAccount(account: [UInt8]) {\n      pre {\n        account.length == 20: \"Ethereum address should be 20 bytes\"\n      }\n\n      self.ethereumAdminAccount = account\n    }\n\n    pub fun getFeeAmount(): UFix64 {\n      return self.feeCollector.balance\n    }\n\n    pub fun depositAllowance(from: @Allowance) {\n      self.allowedAmount = self.allowedAmount + from.balance\n\n      destroy from\n    }\n\n    init(allowedAmount: UFix64) {\n      self.allowedAmount = allowedAmount\n\n      self.feeCollector \u003c- TeleportedTetherToken.createEmptyVault() as! @TeleportedTetherToken.Vault\n      self.inwardFee = 0.01\n      self.outwardFee = 3.0\n\n      self.ethereumAdminAccount = []\n    }\n\n    destroy() {\n      destroy self.feeCollector\n    }\n  }\n\n  init() {\n    self.isFrozen = false\n    self.totalSupply = 0.0\n    self.teleported = {}\n    self.TokenStoragePath = /storage/teleportedTetherTokenVault\n    self.TokenPublicBalancePath = /public/teleportedTetherTokenBalance\n    self.TokenPublicReceiverPath = /public/teleportedTetherTokenReceiver\n\n    let admin \u003c- create Administrator()\n    self.account.save(\u003c-admin, to: /storage/teleportedTetherTokenAdmin)\n\n    // Emit an event that shows that the contract was initialized\n    emit TokensInitialized(initialSupply: self.totalSupply)\n  }\n}\n";
    }, 300);
  },
  methods: {}
};
</script>

<style lang="scss" scoped>
.code-tab {
  border-radius: 4px;
	border: solid 1px #d8dfde;
  .title {
    padding: 30px 20px 20px;
    font-weight: bold;
    border-bottom: 1px solid #d8dfde;
  }
}
</style>
